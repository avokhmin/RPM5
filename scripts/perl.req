#!@__PERL@

# RPM (and its source code) is covered under two separate licenses. 

# The entire code base may be distributed under the terms of the GNU
# General Public License (GPL), which appears immediately below.
# Alternatively, all of the source code in the lib subdirectory of the
# RPM source code distribution as well as any code derived from that
# code may instead be distributed under the GNU Library General Public
# License (LGPL), at the choice of the distributor. The complete text
# of the LGPL appears at the bottom of this file.

# This alternatively is allowed to enable applications to be linked
# against the RPM library (commonly called librpm) without forcing
# such applications to be distributed under the GPL.

# Any questions regarding the licensing of RPM should be addressed to
# Erik Troan <ewt@redhat.com>.

# a simple makedepend like script for perl.
 
# To save development time I do not parse the perl grammmar but
# instead just lex it looking for what I want.  I take special care to
# ignore comments and pod's.

# It would be much better if perl could tell us the dependencies of a
# given script.

# The filenames to scan are either passed on the command line or if
# that is empty they are passed via stdin.

# If there are strings in the file which match the pattern
#     m/^\s*\$RPM_Requires\s*=\s*["'](.*)['"]/i
# then these are treated as additional names which are required by the
# file and are printed as well.

# I plan to rewrite this in C so that perl is not required by RPM at
# build time.

# by Ken Estes Mail.com kestes@staff.mail.com



# *inc variables are used to track dependencies on directories for modules.
# These directories (especially arch-dependent) are likely to change some day.
my @inc = sort { length $b cmp length $a }
          map { s#/*$##; $_ }
          grep m#^/.#, @INC;
my %inc = map { $_ => 0 } @inc;
my $inc = join '|', map "\Q$_\E", @inc;

foreach ( @ARGV ? @ARGV : <> ) {
    chomp;
    $inc{$1}++ if m#($inc)/#;  # can't anchor on ^
    if (m=/usr/(sbin|bin|lib|lib64|share|X11R6/(lib|lib64|bin))/=) {
      if (! m=(/(doc|man|info|usr/src)/|\.(so|ph|h|html|pod)$)=) {
        process_file($_) if -f;
      }
    }
}

foreach (sort keys %provide) {
    delete $require{$_};
}
delete $require{the}; # don't count "use the sth" as perl module  

print "$_\n" for sort grep $inc{$_}, keys %inc;

foreach my $module (sort grep length, keys %require) {
  if (length($require{$module}) == 0) {
    print "perl($module)\n";
  } else {

    # I am not using rpm3.0 so I do not want spaces around my
    # operators. Also I will need to change the processing of the
    # $RPM_* variable when I upgrade.

    print "perl($module) >= $require{$module}\n";
  }
}

exit 0;


sub is_perlfile {
    my $file = shift;
    my $fh = shift;
    
    my $fl = <$fh>;

    my $is_perl = 0;
  
    my $nw = 0;

    if ($file =~ /\.(so|ph|h|html|pod|gz|bz2|png|gif|jpg|xpm|a|patch|o|mo)$/) {
	$is_perl = 0;
	
	# .al, .pl, .pm and .plx (perl-Font-TTF contains *.plx files)
    } elsif ($file =~ /\.p[lm]x?$/ || $file =~ /\.al$/) {	
	$is_perl = 1;
	#print STDERR "$file PERL by ext\n";
    } elsif ($fl =~ m|bin/perl| or $fl =~ m|env\s+perl| or $fl =~ m|exec\s+perl|) {
	$is_perl = 1;
	#print STDERR "$file PERL by perl\n";
    } elsif ($fl =~ m|bin/sh|) {
	while (<$fh>) {
	    if (/eval/ && /perl/) {
		$is_perl = 1;
		last;
	    }
	    $nw++ if (/^\s*BEGIN/); 
	    $nw++ if (/^\s*sub\s+/);
	    $nw++ if (/^\s*package\s+/);
	    $nw++ if (/^\s*use\s+strict\s+;/);
	    $nw++ if (/^\s*use\s+vars\s*qw/);
	    last if ($. > 30);
	}
    }
    
    seek($fh, 0, 0);
    
    $is_perl = 1 if ($nw > 1);  # propably perl file
    
    #if (!$is_perl) {
    #   print STDERR "NOPERL $file\n";
    #   return 0;
    #}	
    #print STDERR "PERL $file\n" if ($is_perl);
    return $is_perl;
}


sub process_file {
  
  my ($file) = @_;
  chomp $file;
  
  open(FILE, "<$file") || return;
  
  return if (!is_perlfile($file, \*FILE));

  while (<FILE>) {
    
    # skip the "= <<" block

    if ( ( m/^\s*\$(.*)\s*=\s*<<\s*["'](.*)['"]/) ||
         ( m/^\s*\$(.*)\s*=\s*<<\s*(.*);/) ) {
      $tag = $2;
      while (<FILE>) {
        ( $_ =~ /^$tag/) && last;
      }
    }

    # skip q{} quoted sections - just hope we don't have curly brackets
    # within the quote, nor an escaped hash mark that isn't a comment
    # marker, such as occurs right here. Draw the line somewhere.
    if ( m/^.*\Wq[qxwr]?\s*([\{\(\[#|\/])[^})\]#|\/]*$/ && ! m/^\s*(require|use)\s/ ) {
      $tag = $1;
      $tag =~ tr/{\(\[\#|\//})]#|\//;
      while (<FILE>) {
        ( $_ =~ m/\}/ ) && last;
      }
    }

    # skip the documentation

    # we should not need to have item in this if statement (it
    # properly belongs in the over/back section) but people do not
    # read the perldoc.

    if ( (m/^=(head[1-4]|pod|item)/) .. (m/^=(cut)/) ) {
      next;
    }

    if ( (m/^=(over)/) .. (m/^=(back)/) ) {
      next;
    }
    
    # skip the data section
    if (m/^__(DATA|END)__$/) {
      last;
    }

    if (m/^\s*package\s+([_:a-zA-Z0-9]+)\s*;/) {
	$provide{$1} = 1;
    }

    # Each keyword can appear multiple times.  Don't
    #  bother with datastructures to store these strings,
    #  if we need to print it print it now.
    #
	# Again allow for "our".
    if ( m/^\s*(our\s+)?\$RPM_Requires\s*=\s*["'](.*)['"]/i) {
      foreach $_ (split(/\s+/, $2)) {
	print "$_\n";
      }
    }

    if ( 

# ouch could be in a eval, perhaps we do not want these since we catch
# an exception they must not be required

#   eval { require Term::ReadLine } or die $@;
#   eval "require Term::Rendezvous;" or die $@;
#   eval { require Carp } if defined $^S; # If error/warning during compilation,


	(m/^(\s*)         # we hope the inclusion starts the line
	 (require|use)\s+(?!\{)     # do not want 'do {' loops
	 # quotes around name are always legal
	 [\'\"]?([^\;\ \'\"\t]*)[\'\"]?[\t\;\ ]
	 # the syntax for 'use' allows version requirements
	 \s*([.0-9]*)
	 /x)
       ) {
      my ($whitespace, $statement, $module, $version) = ($1, $2, $3,$4);

      # we only consider require statements that are flush against
      # the left edge. any other require statements give too many
      # false positives, as they are usually inside of an if statement
      # as a fallback module or a rarely used option

      ($whitespace ne "" && $statement eq "require") && next;

      # if there is some interpolation of variables just skip this
      # dependency, we do not want
      #        do "$ENV{LOGDIR}/$rcfile";
   
      ($module =~ m/\$/) && next;

      # skip if the phrase was "use of" -- shows up in gimp-perl, et al.
      next if $module eq 'of';

      # if the module ends in a comma we probaly caught some
      # documentation of the form 'check stuff,\n do stuff, clean
      # stuff.' there are several of these in the perl distribution

      ($module  =~ m/[,>]$/) && next;

      # if the module name starts in a dot it is not a module name.
      # Is this necessary?  Please give me an example if you turn this
      # back on.

      #      ($module =~ m/^\./) && next;

      # if the module ends with .pm strip it to leave only basename.
      # starts with /, which means its an absolute path to a file
      if ($module =~ m(^/)) {
        print "$module\n";
        next;
      }

      # sometimes people do use POSIX qw(foo), or use POSIX(qw(foo)) etc.
      # we can strip qw.*$, as well as (.*$:
      $module =~ s/qw.*$//;
      $module =~ s/\(.*$//;

      $module =~ s/\.pm$//;

      # some perl programmers write 'require URI/URL;' when 
      # they mean 'require URI::URL;'

      $module =~ s/\//::/;

      # trim off trailing parentheses if any.  Sometimes people pass
      # the module an empty list.

      $module =~ s/\(\s*\)$//;

      if ( $module =~ m/^(v?)([0-9._]+)$/ ) {
      # if module is a number then both require and use interpret that
      # to mean that a particular version of perl is specified

	my $ver=$2;
	if (($1 eq 'v') or ($ver =~ /[0-9]+\.[0-9]+\.[0-9]+/)) {
	  # $V-style
	  if ($ver =~ m/5\.([0-5])(\.([0-9]+))?$/) {
	    if (defined $3) {
	      print "perl >= 0:5.00$1_$3\n";
	    } else {
	      print "perl >= 0:5.00$1\n";
	    }
	  } else {
	    print "perl >= 1:$ver\n";
	  }
	} else {
	  # $]-style
	  if ($ver =~ m/5\.(00[0-5])_?([0-9]+)?$/) {
	    if (defined $2) {
	      print "perl >= 0:5.$1_$2\n";
	    } else {
	      print "perl >= 0:5.$1\n";
	    }
	  } else {
	    # expand to M.NNN_nnn form
	    $ver =~ s/^([0-9])$/$1./;
	    $ver =~ s/^([0-9]\.[0-9]{0,5}|[0-9]\.[0-9]{3}_[0-9]{0,2})$/${1}000000/;
	    $ver =~ s/^([0-9]\.[0-9]{3})_?([0-9]{3})0*$/$1_$2/;
	    # match trimming leading 0s
	    $ver =~ m/^([0-9])\.0*([1-9][0-9]*|0)_0*([1-9][0-9]*|0)$/;
	    print "perl >= 1:$1.$2.$3\n";
	  }
	}
	next;

      };

      # ph files do not use the package name inside the file.
      # perlmodlib documentation says:
      
      #       the .ph files made by h2ph will probably end up as
      #       extension modules made by h2xs.
      
      # so do not expend much effort on these.


      # there is no easy way to find out if a file named systeminfo.ph
      # will be included with the name sys/systeminfo.ph so only use the
      # basename of *.ph files

      # ($module  =~ m/\.ph$/) && ($module =~ s!.*/!!g );
 
      # there is no need to generate dependencies for ph, pl or test files
      # so let's just skip them.

      ($module =~ m/\.(ph|pl|t)$/) && next;

      # if the module name starts in a dot it is not a module name.

      ($module =~ m/^\./) && next;

      # name starts in a non alphanumeric character it is not a module 
      # name.
      ($module =~ m/^\W/) && next;

      # if the module ends with .pm strip it to leave only basename.

      $module =~ s/\.pm$//;

      $module =~ s/\//::/;

      # trim off trailing parenthesis if any.  Sometimes people pass
      # the module an empty list.

      $module =~ s/\(\s*\)$//;

      $require{$module}=$version;
      $line{$module}=$_;
    }
    
  }

  close(FILE) ||
    die("$0: Could not close file: '$file' : $!\n");
  
  return ; 
}
